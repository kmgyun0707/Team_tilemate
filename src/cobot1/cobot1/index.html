<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>TILING MONITOR - 두산 M0609</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { font-family: 'Malgun Gothic', sans-serif; background-color: #f0f2f5; padding: 20px; color: #333; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        
        header { border-bottom: 3px solid #1a237e; margin-bottom: 25px; padding-bottom: 10px; text-align: center; }
        h1 { font-size: 42px; color: #1a237e; margin: 0; letter-spacing: 2px; }
        
        .info-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 25px; }
        .info-item { font-size: 1.1em; font-weight: bold; }
        .info-item span { color: #d32f2f; }
        
        #timer-container { grid-column: span 2; text-align: center; font-size: 1.5em; background: #eee; padding: 5px; border-radius: 5px; margin-bottom: 10px; }

        .control-panel { display: flex; gap: 15px; margin-bottom: 30px; }
        button { flex: 1; padding: 20px; font-size: 1.5em; font-weight: bold; border: none; border-radius: 10px; cursor: pointer; transition: 0.3s; }
        #btn-start { background-color: #e8f5e9; color: #2e7d32; border: 2px solid #2e7d32; }
        #btn-pause { background-color: #fff3e0; color: #ef6c00; border: 2px solid #ef6c00; }
        #btn-reset { background-color: #ffebee; color: #c62828; border: 2px solid #c62828; }

        .process-flow { display: flex; justify-content: space-between; background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #ddd; margin-bottom: 25px; }
        .step { font-weight: bold; color: #999; font-size: 1.1em; padding: 5px 15px; border-radius: 20px; }
        .step.active { background-color: #ff0000; color: #ffffff !important; box-shadow: 0 0 10px rgba(255,0,0,0.5); }

        .bottom-section { display: flex; gap: 20px; align-items: stretch; }
        
        /* 3x3 그리드 */
        .tile-grid-wrapper {
            flex: 1.5;
            display: flex;
            flex-direction: column;
        }
        .tile-grid { 
            flex: 1;
            display: grid; 
            grid-template-columns: repeat(3, 1fr);
            gap: 10px; 
            background: #e9ecef; 
            padding: 15px; 
            border-radius: 12px; 
            border: 1px solid #ccc;
            align-content: center;
        }
        .tile { 
            aspect-ratio: 1 / 1;
            background-color: #ffffff; 
            border: 2px solid #ddd; 
            border-radius: 6px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 1.05em; 
            font-weight: bold; 
            color: #555; 
            transition: all 0.4s ease; 
        }

        .tile.working  { background-color: #ffc107; border-color: #ff9800; color: white; }
        .tile.running  { background-color: #4caf50; border-color: #2e7d32; color: white; }
        .tile.finished { background-color: #1a237e; border-color: #0d124a; color: white; }
        
        #three-container { flex: 1.5; height: 450px; background: #f8f9fa; border-radius: 12px; border: 1px solid #ccc; }
    </style>
</head>
<body>

<div class="container">
    <header><h1>TILING MONITOR</h1></header>

    <div class="info-grid">
        <div id="timer-container">타일링 시간: <span id="timer">00 : 00 : 00</span></div>
        <div class="info-item">타일링 진행도: <span id="job-count">0</span> / <span id="total-tiles">9</span></div>
        <div class="info-item" style="text-align: right;">로봇속도: <span id="robot-speed">0</span>%</div>
        <div class="info-item">충돌민감도: <span id="collision-sens">0</span></div>
        <div class="info-item" style="text-align: right;">상태: <span id="robot-state">대기</span></div>
    </div>

    <div class="control-panel">
        <button id="btn-start" onclick="sendCommand('start')">시작</button>
        <button id="btn-pause" onclick="sendCommand('pause')">비상정지</button>
        <button id="btn-reset" onclick="resetSystem()">초기화</button>
    </div>

    <div class="process-flow">
        <div id="step1" class="step">접착제 파지</div>
        <div class="step">→</div>
        <div id="step2" class="step">접착제 도포</div>
        <div class="step">→</div>
        <div id="step3" class="step">타일 파지</div>
        <div class="step">→</div>
        <div id="step4" class="step">타일 배치</div>
    </div>

    <div class="bottom-section">
        <div class="tile-grid-wrapper">
            <div class="tile-grid" id="tile-map"></div>
            <div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; display: flex; gap: 20px; justify-content: center; font-size: 0.95em; flex-wrap: wrap;">
                <div style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 20px; height: 20px; background: #ffc107; border: 2px solid #ff9800; border-radius: 4px;"></div>
                    <span>작업중</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 20px; height: 20px; background: #4caf50; border: 2px solid #2e7d32; border-radius: 4px;"></div>
                    <span>마르는중</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 20px; height: 20px; background: #1a237e; border: 2px solid #0d124a; border-radius: 4px;"></div>
                    <span>완료</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 20px; height: 20px; background: #e53935; border: 2px solid #b71c1c; border-radius: 4px;"></div>
                    <span>빨강타일</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 20px; height: 20px; background: #212121; border: 2px solid #000; border-radius: 4px;"></div>
                    <span>검정타일</span>
                </div>
            </div>
        </div>
        <div id="three-container"></div>
    </div>
</div>

<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

<script>
    let database;
    
    const firebaseConfig = {
        apiKey: "AIzaSyDPPouqUOm8Ib6blpADMf-VQ_5r9-_IyEk",
        authDomain: "co1-tiling.firebaseapp.com",
        databaseURL: "https://co1-tiling-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "co1-tiling",
        storageBucket: "co1-tiling.firebasestorage.app",
        messagingSenderId: "925424727446",
        appId: "1:925424727446:web:85cc99cd5a478fa50759b7"
    };
    
    try {
        firebase.initializeApp(firebaseConfig);
        database = firebase.database();
        console.log('Firebase initialized successfully!');
    } catch(error) {
        console.error('Firebase initialization error:', error);
    }

    const TOTAL_TILES = 9; // 3x3
    const COLS = 3;
    const ROWS = 3;

    let timerInterval = null;
    let startTime = null;
    let elapsedSeconds = 0;
    let prevCompletedJobs = 0;
    let isStarted = false;

    // 각 타일의 고유 색상 (red/black) 추적 - null이면 기본 상태색 사용
    // 타일 색상이 지정되면 작업진행 상태(노란/초록/파란)와 무관하게 이 색상 유지
    const tileColors = new Array(TOTAL_TILES + 1).fill(null); // 1-indexed

    // -------------------------------------------------------
    // 2D 타일 그리드 생성 (9칸: 3행 3열)
    // -------------------------------------------------------
    const tileMap = document.getElementById('tile-map');
    const activeTimers = {};
    for (let i = 1; i <= TOTAL_TILES; i++) {
        const tile = document.createElement('div');
        tile.classList.add('tile');
        tile.id = `tile-${i}`;
        tileMap.appendChild(tile);
    }

    // -------------------------------------------------------
    // Three.js 3D 설정
    // -------------------------------------------------------
    const container = document.getElementById('three-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f2f5);

    const camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(5, 5, 5);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const light = new THREE.DirectionalLight(0xffffff, 0.5);
    light.position.set(10, 20, 10);
    scene.add(light);

    // 3D 타일 생성 (3x3)
    const tiles3D = [];
    const tileGeom = new THREE.BoxGeometry(0.8, 0.1, 0.8);
    const tileGap = 0.9;
    const startX = -((COLS - 1) * tileGap) / 2;
    const startZ = -((ROWS - 1) * tileGap) / 2;

    for (let i = 0; i < TOTAL_TILES; i++) {
        const mesh = new THREE.Mesh(
            tileGeom,
            new THREE.MeshStandardMaterial({ color: 0xffffff })
        );
        const row = Math.floor(i / COLS);
        const col = i % COLS;
        mesh.position.set(startX + col * tileGap, 0.05, startZ + row * tileGap);
        scene.add(mesh);
        tiles3D.push(mesh);
    }

    // 벽 위치 계산
    const tileSize = 0.8;
    const tileEndX   = startX + (COLS - 1) * tileGap + tileSize / 2;
    const tileStartX = startX - tileSize / 2;
    const tileEndZ   = startZ + (ROWS - 1) * tileGap + tileSize / 2;
    const tileStartZ = startZ - tileSize / 2;
    const padding = 0.05;

    const wallMat = new THREE.MeshStandardMaterial({ color: 0x999999, transparent: true, opacity: 0.6 });
    const wallThickness = 0.2;

    // 뒤쪽 벽
    const backWall = new THREE.Mesh(
        new THREE.BoxGeometry(tileEndX - tileStartX, 2.5, wallThickness),
        wallMat
    );
    backWall.position.set(
        (tileStartX + tileEndX) / 2,
        1.25,
        tileStartZ - padding - wallThickness / 2
    );
    scene.add(backWall);

    // 왼쪽 벽
    const sideWall = new THREE.Mesh(
        new THREE.BoxGeometry(wallThickness, 2.5, tileEndZ - tileStartZ),
        wallMat
    );
    sideWall.position.set(
        tileStartX - padding - wallThickness / 2,
        1.25,
        (tileStartZ + tileEndZ) / 2
    );
    scene.add(sideWall);

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    // -------------------------------------------------------
    // Firebase: robot_status 실시간 수신
    // -------------------------------------------------------
    database.ref('robot_status').on('value', (snapshot) => {
        const data = snapshot.val();
        if (!data) return;

        document.getElementById('robot-speed').innerText     = data.speed || 0;
        document.getElementById('robot-state').innerText     = data.state || "대기";
        document.getElementById('collision-sens').innerText  = data.collision_sensitivity || 0;
        document.getElementById('job-count').innerText       = data.completed_jobs || 0;

        updateProcessStep(data.current_step || 0);

        // --- red_tile: 타일 고유 색상이 빨간 타일 ---
        if (data.red_tile !== undefined && data.red_tile !== null) {
            const idx = parseInt(data.red_tile);
            if (idx >= 1 && idx <= TOTAL_TILES) {
                tileColors[idx] = 0xe53935;
                tiles3D[idx - 1].material.color.setHex(0xe53935);
                console.log(`[RED TILE] tile-${idx} -> red`);
            }
        }

        // --- black_tile: 타일 고유 색상이 검정 타일 ---
        if (data.black_tile !== undefined && data.black_tile !== null) {
            const idx = parseInt(data.black_tile);
            if (idx >= 1 && idx <= TOTAL_TILES) {
                tileColors[idx] = 0x212121;
                tiles3D[idx - 1].material.color.setHex(0x212121);
                console.log(`[BLACK TILE] tile-${idx} -> black`);
            }
        }

        if (!isStarted) return;

        const currentJobs = data.completed_jobs || 0;

        if (currentJobs > prevCompletedJobs) {
            for (let i = prevCompletedJobs + 1; i <= currentJobs; i++) {
                startTileTimer(i, 120);
            }
        }

        // 현재 작업 중인 타일 노란색 (2D만)
        const workingIdx = currentJobs + 1;
        if (workingIdx <= TOTAL_TILES) {
            const el = document.getElementById(`tile-${workingIdx}`);
            const mesh = tiles3D[workingIdx - 1];
            if (el && !el.classList.contains('running') && !el.classList.contains('finished')) {
                el.classList.add('working');
                el.innerText = '작업중';
                // 3D: 타일 고유 색상(red/black)이 있으면 유지, 없으면 노란색
                if (mesh && tileColors[workingIdx] !== null) {
                    mesh.material.color.setHex(tileColors[workingIdx]);
                } else if (mesh) {
                    mesh.material.color.setHex(0xffc107);
                }
            }
        }

        prevCompletedJobs = currentJobs;
    });

    // -------------------------------------------------------
    // 공정 단계 업데이트
    // -------------------------------------------------------
    function updateProcessStep(stepNumber) {
        for (let i = 1; i <= 4; i++) {
            const el = document.getElementById('step' + i);
            if (el) el.classList.remove('active');
        }
        if (stepNumber > 0 && stepNumber <= 4) {
            const el = document.getElementById('step' + stepNumber);
            if (el) el.classList.add('active');
        }
    }

    // -------------------------------------------------------
    // 버튼 커맨드
    // -------------------------------------------------------
    function sendCommand(cmd) {
        database.ref('robot_command').set({ action: cmd, timestamp: Date.now() });

        if (cmd === 'start') {
            isStarted = true;
            if (!timerInterval) startTimer();

            const firstTile = document.getElementById('tile-1');
            const firstMesh = tiles3D[0];
            if (firstTile && !firstTile.classList.contains('running') && !firstTile.classList.contains('finished')) {
                firstTile.classList.add('working');
                firstTile.innerText = '작업중';
                if (firstMesh) {
                    firstMesh.material.color.setHex(tileColors[1] !== null ? tileColors[1] : 0xffc107);
                }
            }
        } else if (cmd === 'pause') {
            pauseTimer();
        }
    }
    window.sendCommand = sendCommand;

    // -------------------------------------------------------
    // 타이머
    // -------------------------------------------------------
    function startTimer() {
        if (timerInterval) return;
        startTime = Date.now() - (elapsedSeconds * 1000);
        timerInterval = setInterval(() => {
            elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
            updateTimerDisplay();
        }, 1000);
    }

    function updateTimerDisplay() {
        const h = Math.floor(elapsedSeconds / 3600);
        const m = Math.floor((elapsedSeconds % 3600) / 60);
        const s = elapsedSeconds % 60;
        document.getElementById('timer').innerText =
            `${String(h).padStart(2,'0')} : ${String(m).padStart(2,'0')} : ${String(s).padStart(2,'0')}`;
    }

    function pauseTimer() {
        if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
    }

    // -------------------------------------------------------
    // 초기화
    // -------------------------------------------------------
    function resetSystem() {
        pauseTimer();
        startTime = null;
        elapsedSeconds = 0;
        isStarted = false;
        prevCompletedJobs = 0;
        document.getElementById('timer').innerText = '00 : 00 : 00';

        database.ref('robot_status').update({
            completed_jobs: 0,
            working_tile: 0,
            current_step: 0,
            speed: 0,
            state: '대기',
            red_tile: null,
            black_tile: null
        });
        database.ref('robot_command').set({ action: 'reset', timestamp: Date.now() });

        for (let id in activeTimers) clearInterval(activeTimers[id]);
        Object.keys(activeTimers).forEach(key => delete activeTimers[key]);

        for (let i = 1; i <= TOTAL_TILES; i++) {
            tileColors[i] = null; // 타일 고유 색상 초기화
            const el = document.getElementById(`tile-${i}`);
            if (el) { el.classList.remove('working', 'running', 'finished'); el.innerText = ''; }
        }

        tiles3D.forEach(mesh => mesh.material.color.setHex(0xffffff));
        updateProcessStep(0);
        console.log('System reset completed!');
    }
    window.resetSystem = resetSystem;

    // -------------------------------------------------------
    // 타일 타이머 (마르는 중 → 완료)
    // -------------------------------------------------------
    function startTileTimer(id, sec) {
        let left = sec;
        const el = document.getElementById(`tile-${id}`);
        const mesh = tiles3D[id - 1];
        if (!el || el.classList.contains('finished')) return;

        el.classList.remove('working');
        el.classList.add('running');
        // 3D: 타일 고유 색상(red/black)이 있으면 유지, 없으면 초록색
        if (mesh) {
            mesh.material.color.setHex(tileColors[id] !== null ? tileColors[id] : 0x4caf50);
        }

        activeTimers[id] = setInterval(() => {
            left--;
            const m = Math.floor(left / 60);
            const s = left % 60;
            el.innerText = `${m}:${s < 10 ? '0' + s : s}`;

            if (left <= 0) {
                clearInterval(activeTimers[id]);
                el.innerText = "완료";
                el.classList.remove('running');
                el.classList.add('finished');
                // 3D: 타일 고유 색상(red/black)이 있으면 유지, 없으면 파란색
                if (mesh) {
                    mesh.material.color.setHex(tileColors[id] !== null ? tileColors[id] : 0x1a237e);
                }
            }
        }, 1000);
    }

    window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });
</script>
</body>
</html>