<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>TILING MONITOR - 두산 M0609</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        /* 기본 레이아웃 및 스타일 설정 */
        body { font-family: 'Malgun Gothic', sans-serif; background-color: #f0f2f5; padding: 20px; color: #333; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 30px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); }
        
        header { border-bottom: 3px solid #1a237e; margin-bottom: 25px; padding-bottom: 10px; text-align: center; }
        h1 { font-size: 42px; color: #1a237e; margin: 0; letter-spacing: 2px; }
        
        /* 정보 표시용 그리드 */
        .info-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 25px; }
        .info-item { font-size: 1.1em; font-weight: bold; }
        .info-item span { color: #d32f2f; }
        
        #timer-container { grid-column: span 2; text-align: center; font-size: 1.5em; background: #eee; padding: 5px; border-radius: 5px; margin-bottom: 10px; }

        /* 제어 버튼 영역 */
        .control-panel { display: flex; gap: 15px; margin-bottom: 30px; }
        button { flex: 1; padding: 20px; font-size: 1.5em; font-weight: bold; border: none; border-radius: 10px; cursor: pointer; transition: 0.3s; }
        #btn-start { background-color: #e8f5e9; color: #2e7d32; border: 2px solid #2e7d32; }
        #btn-pause { background-color: #fff3e0; color: #ef6c00; border: 2px solid #ef6c00; }
        #btn-reset { background-color: #ffebee; color: #c62828; border: 2px solid #c62828; }

        /* 공정 단계 표시 */
        .process-flow { display: flex; justify-content: space-between; background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #ddd; margin-bottom: 25px; }
        .step { font-weight: bold; color: #999; font-size: 1.1em; padding: 5px 15px; border-radius: 20px; }
        .step.active { background-color: #ff0000; color: #ffffff !important; box-shadow: 0 0 10px rgba(255,0,0,0.5); }

        /* 하단 메인 섹션 */
        .bottom-section { display: flex; gap: 20px; align-items: flex-start; }
        
        /* [수정] 2D 타일 그리드 및 타일 크기 확대 */
        .tile-grid { 
            flex: 1.5; 
            display: grid; 
            grid-template-columns: repeat(9, 1fr); 
            gap: 5px; 
            background: #e9ecef; 
            padding: 10px; 
            border-radius: 12px; 
            border: 1px solid #ccc; 
        }
        .tile { 
            aspect-ratio: 1 / 1; 
            background-color: #ffffff; 
            border: 2px solid #ddd; 
            border-radius: 6px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            font-size: 0.9em; 
            font-weight: bold; 
            color: #555; 
            transition: all 0.4s ease; 
        }

        .tile.working { background-color: #ffc107; border-color: #ff9800; color: white; }
        .tile.running { background-color: #4caf50; border-color: #2e7d32; color: white; }
        .tile.finished { background-color: #1a237e; border-color: #0d124a; color: white; }
        
        #three-container { flex: 1.5; height: 450px; background: #f8f9fa; border-radius: 12px; border: 1px solid #ccc; }
    </style>
</head>
<body>

<div class="container">
    <header><h1>TILING MONITOR</h1></header>

    <div class="info-grid">
        <div id="timer-container">타일링 시간: <span id="timer">00 : 00 : 00</span></div>
        <div class="info-item">타일링 진행도: <span id="job-count">0</span> / <span id="total-tiles">45</span></div>
        <div class="info-item" style="text-align: right;">로봇속도: <span id="robot-speed">0</span>%</div>
        <div class="info-item">충돌민감도: <span id="collision-sens">0</span></div>
        <div class="info-item" style="text-align: right;">상태: <span id="robot-state">대기</span></div>
    </div>

    <div class="control-panel">
        <button id="btn-start" onclick="sendCommand('start')">시작</button>
        <button id="btn-pause" onclick="sendCommand('pause')">일시정지</button>
        <button id="btn-reset" onclick="resetSystem()">초기화</button>
    </div>

    <div class="process-flow">
        <div id="step1" class="step">접착제 파지</div>
        <div class="step">→</div>
        <div id="step2" class="step">접착제 도포</div>
        <div class="step">→</div>
        <div id="step3" class="step">타일 파지</div>
        <div class="step">→</div>
        <div id="step4" class="step">타일 배치</div>
    </div>

    <div class="bottom-section">
        <div style="flex: 1.5;">
            <div class="tile-grid" id="tile-map"></div>
            <div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 8px; display: flex; gap: 20px; justify-content: center; font-size: 0.95em;">
                <div style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 20px; height: 20px; background: #ffc107; border: 2px solid #ff9800; border-radius: 4px;"></div>
                    <span>작업중</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 20px; height: 20px; background: #4caf50; border: 2px solid #2e7d32; border-radius: 4px;"></div>
                    <span>마르는중</span>
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <div style="width: 20px; height: 20px; background: #1a237e; border: 2px solid #0d124a; border-radius: 4px;"></div>
                    <span>완료</span>
                </div>
            </div>
        </div>
        <div id="three-container"></div>
    </div>
</div>

<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>

<script>
    console.log('Script loading started...');
    
    // 전역 변수 선언
    let database;
    
    // Firebase 초기화 설정
    const firebaseConfig = {
        apiKey: "AIzaSyDPPouqUOm8Ib6blpADMf-VQ_5r9-_IyEk",
        authDomain: "co1-tiling.firebaseapp.com",
        databaseURL: "https://co1-tiling-default-rtdb.asia-southeast1.firebasedatabase.app",
        projectId: "co1-tiling",
        storageBucket: "co1-tiling.firebasestorage.app",
        messagingSenderId: "925424727446",
        appId: "1:925424727446:web:85cc99cd5a478fa50759b7"
    };
    
    try {
        firebase.initializeApp(firebaseConfig);
        database = firebase.database();
        console.log('Firebase initialized successfully!');
    } catch(error) {
        console.error('Firebase initialization error:', error);
    }

    // 타이머 관련 변수
    let timerInterval = null;
    let startTime = null;
    let elapsedSeconds = 0;
    console.log('Timer variables initialized');

    // 2D 타일 그리드 생성
    const tileMap = document.getElementById('tile-map');
    const activeTimers = {};
    for (let i = 1; i <= 45; i++) {
        const tile = document.createElement('div');
        tile.classList.add('tile');
        tile.id = `tile-${i}`;
        tile.innerText = "";
        tileMap.appendChild(tile);
    }

    // Three.js 3D 모니터링 설정
    const container = document.getElementById('three-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f2f5);

    const camera = new THREE.PerspectiveCamera(40, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(12, 10, 12);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    
    // 조명 추가
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const light = new THREE.DirectionalLight(0xffffff, 0.5);
    light.position.set(10, 20, 10);
    scene.add(light);

    // 3D 타일 배열 생성 (먼저 생성해야 벽 위치 계산 가능)
    const tiles3D = [];
    const tileGeom = new THREE.BoxGeometry(0.8, 0.1, 0.8);
    const tileSize = 0.8;
    const tileGap = 0.9;
    const startX = -4.6;
    const startZ = -3.1;
    
    for (let i = 0; i < 45; i++) {
        const mesh = new THREE.Mesh(tileGeom, new THREE.MeshStandardMaterial({ color: 0xffffff }));
        const row = Math.floor(i / 9);
        const col = i % 9;
        mesh.position.set(startX + col * tileGap, 0.05, startZ + row * tileGap);
        scene.add(mesh);
        tiles3D.push(mesh);
    }
    
    // 타일 배열의 실제 끝 위치 계산
    const lastCol = 8; // 9개 열 (0~8)
    const lastRow = 4; // 5개 행 (0~4)
    const tileEndX = startX + lastCol * tileGap + tileSize / 2; // 오른쪽 끝
    const tileStartX = startX - tileSize / 2; // 왼쪽 끝
    const tileEndZ = startZ + lastRow * tileGap + tileSize / 2; // 앞쪽 끝
    const tileStartZ = startZ - tileSize / 2; // 뒤쪽 끝
    
    const padding = 0.05; // 5px 패딩

    
    // [수정] 3D 벽 2개 추가 (타일 끝 + 패딩에 정확히 맞춤)
    const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x999999, transparent: true, opacity: 0.6 });
    const wallThickness = 0.2;
    
    // 가로 벽 (뒤쪽) - 타일의 왼쪽 끝부터 오른쪽 끝까지
    const backWallWidth = tileEndX - tileStartX;
    const backWall = new THREE.Mesh(
        new THREE.BoxGeometry(backWallWidth, 2.5, wallThickness), 
        wallMaterial
    );
    backWall.position.set(
        (tileStartX + tileEndX) / 2,  // 중심 X
        1.25,                          // 높이
        tileStartZ - padding - wallThickness / 2  // 뒤쪽 끝 + 패딩
    );
    scene.add(backWall);

    // 세로 벽 (왼쪽) - 타일의 뒤쪽 끝부터 앞쪽 끝까지
    const sideWallDepth = tileEndZ - tileStartZ;
    const sideWall = new THREE.Mesh(
        new THREE.BoxGeometry(wallThickness, 2.5, sideWallDepth), 
        wallMaterial
    );
    sideWall.position.set(
        tileStartX - padding - wallThickness / 2,  // 왼쪽 끝 + 패딩
        1.25,                                       // 높이
        (tileStartZ + tileEndZ) / 2                // 중심 Z
    );
    scene.add(sideWall);

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }
    animate();

    // Firebase 데이터 실시간 수신 및 업데이트
    database.ref('robot_status').on('value', (snapshot) => {
        const data = snapshot.val();
        if(!data) return;

        document.getElementById('robot-speed').innerText = data.speed || 0;
        document.getElementById('robot-state').innerText = data.state || "대기";
        document.getElementById('collision-sens').innerText = data.collision_sensitivity || 0;
        document.getElementById('job-count').innerText = data.completed_jobs || 0;
        
        // 공정 단계 업데이트 (0이면 하이라이트 없음)
        updateProcessStep(data.current_step || 0);
        
        // 작업 중인 타일 노란색 표시
        if(data.working_tile) {
            const workingTile = document.getElementById(`tile-${data.working_tile}`);
            const workingMesh = tiles3D[data.working_tile - 1];
            if(workingTile && !workingTile.classList.contains('running') && !workingTile.classList.contains('finished')) {
                workingTile.classList.add('working');
                workingTile.innerText = '작업중';
                if(workingMesh) workingMesh.material.color.setHex(0xffc107); // 노란색
            }
        }
        
        // 작업 진행 시 타일 시각화 (초록색 - 마르는중)
        if(data.completed_jobs) updateVisuals(data.completed_jobs);
    });

    function updateProcessStep(stepNumber) {
        for(let i=1; i<=4; i++) {
            const el = document.getElementById('step' + i);
            if(el) el.classList.remove('active');
        }
        // stepNumber가 0이 아닐 때만 하이라이트
        if(stepNumber > 0) {
            const current = document.getElementById('step' + stepNumber);
            if(current) current.classList.add('active');
        }
    }

    function sendCommand(cmd) {
        console.log('sendCommand called with:', cmd);
        database.ref('robot_command').set({ action: cmd, timestamp: Date.now() });
        
        // 시작 버튼을 누르면 타이머 시작 또는 재개
        if(cmd === 'start') {
            console.log('Start button clicked, attempting to start timer...');
            if(!timerInterval) {
                startTimer();
            } else {
                console.log('Timer already running');
            }
        }
        // 일시정지 버튼을 누르면 타이머 일시정지
        else if(cmd === 'pause') {
            console.log('Pause button clicked');
            pauseTimer();
        }
    }
    
    // 전역으로 함수 노출
    window.sendCommand = sendCommand;
    console.log('sendCommand function registered');

    function startTimer() {
        console.log('startTimer function called');
        
        // 타이머가 이미 실행 중이면 return
        if(timerInterval) {
            console.log('Timer already running, skipping...');
            return;
        }
        
        if(!startTime) {
            startTime = Date.now() - (elapsedSeconds * 1000);
            console.log('Starting timer from 0, startTime:', startTime);
        } else {
            // 일시정지 후 재개할 때
            startTime = Date.now() - (elapsedSeconds * 1000);
            console.log('Resuming timer, elapsedSeconds:', elapsedSeconds);
        }
        
        console.log('About to create setInterval...');
        timerInterval = setInterval(() => {
            console.log('Inside setInterval callback, elapsedSeconds before:', elapsedSeconds);
            elapsedSeconds = Math.floor((Date.now() - startTime) / 1000);
            console.log('Inside setInterval callback, elapsedSeconds after:', elapsedSeconds);
            updateTimerDisplay();
        }, 1000);
        
        console.log('Timer started! Interval ID:', timerInterval);
    }

    function updateTimerDisplay() {
        const hours = Math.floor(elapsedSeconds / 3600);
        const minutes = Math.floor((elapsedSeconds % 3600) / 60);
        const seconds = elapsedSeconds % 60;
        
        const display = `${String(hours).padStart(2, '0')} : ${String(minutes).padStart(2, '0')} : ${String(seconds).padStart(2, '0')}`;
        document.getElementById('timer').innerText = display;
        console.log('Timer display updated:', display);
    }

    function pauseTimer() {
        if(timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
            console.log('Timer paused at:', elapsedSeconds);
        }
    }

    function resetSystem() {
    // 1. 타이머 정지 및 초기화
    if(timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
    }
    startTime = null;
    elapsedSeconds = 0;
    document.getElementById('timer').innerText = '00 : 00 : 00';
    
    // 2. Firebase 데이터 초기화 (핵심: working_tile 추가)
    database.ref('robot_status').update({
        completed_jobs: 0,
        working_tile: 0,   // 작업 중인 타일 정보 초기화
        current_step: 0,
        speed: 0,
        state: '대기'
    });
    
    database.ref('robot_command').set({ 
        action: 'reset', 
        timestamp: Date.now() 
    });
    
    // 3. 모든 타일 개별 타이머(마르는 중) 정지 및 데이터 삭제
    for(let id in activeTimers) {
        clearInterval(activeTimers[id]);
    }
    Object.keys(activeTimers).forEach(key => delete activeTimers[key]);
    
    // 4. 2D 타일 UI 초기화 (노란색/초록색/파란색 제거)
    for(let i = 1; i <= 45; i++) {
        const el = document.getElementById(`tile-${i}`);
        if(el) {
            el.classList.remove('working', 'running', 'finished');
            el.innerText = '';
        }
    }
    
    // 5. 3D 타일 모델 초기화 (모든 타일을 다시 흰색으로)
    if (tiles3D && tiles3D.length > 0) {
        tiles3D.forEach(mesh => {
            mesh.material.color.setHex(0xffffff);
        });
    }
    
    // 6. 공정 단계 하이라이트(빨간불) 제거
    updateProcessStep(0);
    
    console.log('System reset completed including 3D tiles and working state!');
}

    // 전역으로 함수 노출
    window.resetSystem = resetSystem;
    console.log('resetSystem function registered');

    function updateVisuals(count) {
        for (let i = 1; i <= count; i++) {
            if (!activeTimers[i]) startTileTimer(i, 120);
        }
    }

    function startTileTimer(id, sec) {
        let left = sec;
        const el = document.getElementById(`tile-${id}`);
        const mesh = tiles3D[id-1];
        if(!el || el.classList.contains('finished')) return;

        // 작업중(노란색)에서 마르는중(초록색)으로 변경
        el.classList.remove('working');
        el.classList.add('running');
        mesh.material.color.setHex(0x4caf50); // 초록색 (마르는중)

        activeTimers[id] = setInterval(() => {
            left--;
            const m = Math.floor(left / 60);
            const s = left % 60;
            el.innerText = `${m}:${s < 10 ? '0'+s : s}`;
            
            if(left <= 0) {
                clearInterval(activeTimers[id]);
                el.innerText = "완료";
                el.classList.remove('running');
                el.classList.add('finished');
                mesh.material.color.setHex(0x1a237e); // 파란색 (완료)
            }
        }, 1000);
    }

    window.addEventListener('resize', () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    });
</script>
</body>
</html>